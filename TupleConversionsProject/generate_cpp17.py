#!/usr/bin/python

# Copyright (c) 2018
# Call file:
# python ./generate_cpp17.py > TupleConversions/Private/structurebindings_generated.h

############################################################################################################################

import sys
import string

# Skipping some letters that may produce keywords or are hard to read, or shadow template parameters
ascii_letters = string.ascii_letters.replace("o", "").replace("O", "").replace("i", "").replace("I", "").replace("T", "")

PROLOGUE = """#ifndef STRUCTURE_BINDING_GENERATED_HPP
#define STRUCTURE_BINDING_GENERATED_HPP
#pragma once

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////// This is an auto generated header. Modify generate_cpp17.py instead.   ////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#include <tuple>
#include <type_traits>

/**
 * @file
 * @brief Contains detail functions for converting struct to std::tuple
 *
 * Contains detail functions for converting struct to std::tuple.
 * This file is auto-generated by generate_cpp17.py
 * @warning Dont use this functions directly!
 * @ingroup TupleConversions
 */

namespace TupleConversions::Detail {

template <class T>
constexpr auto toTupleImpl(
    T&&, std::integral_constant<std::size_t, 0>
    ) noexcept
{
    return std::make_tuple();
}

template <class T>
constexpr auto toTupleImpl(
    T&& val, std::integral_constant<std::size_t, 1>
    ) noexcept
{
    auto&& [a] = std::forward<T>(val);
    return std::make_tuple(a);
}

"""

############################################################################################################################
EPILOGUE = """
} // TupleConversions::Detail

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif // BOOST_PFR_DETAIL_CORE17_GENERATED_HPP
"""

############################################################################################################################

indexes = "        a"
print PROLOGUE

funcs_count = 100 if len(sys.argv) == 1 else int(sys.argv[1])
max_args_on_a_line = 10#len(ascii_letters)
for i in xrange(1, funcs_count):
    if i % max_args_on_a_line == 0:
        indexes += ",\n        "
    else:
        indexes += ", "

    if i >= max_args_on_a_line:
        indexes += ascii_letters[i / max_args_on_a_line - 1] 
    indexes += ascii_letters[i % max_args_on_a_line]

    print "template <class T>"
    print "constexpr auto toTupleImpl("
    print "    T&& val, std::integral_constant<std::size_t, " + str(i + 1) + ">"
    print "    ) noexcept"
    print "{"
    print "    auto&& ["
    print indexes
    print "    ] = std::forward<T>(val);"
    print ""
    print "    return std::make_tuple("
    print indexes
    print "    );"
    print "}\n"


print "template <class T, size_t N>"
print "constexpr auto toTupleImpl("
print "    T&& val, std::integral_constant<std::size_t, N>"
print "    ) noexcept"
print "{"
print "    static_assert(N < " + str(funcs_count + 1) + ");"
print "}"

print EPILOGUE
